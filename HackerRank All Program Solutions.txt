/*HackerRank Program Solution*/

// Say "Hello,World!" With C++

#include <iostream>
#include <cstdio>

using namespace std;

int main()
{
    cout<<"Hello, World!";

    return 0;
}

// Input and Output

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */  
    int a,b,c;
    cin >> a >> b >> c; 
    cout << a+b+c << endl;
    return 0;
}

// Basic Data Types

#include <iostream>
#include <cstdio>
#include <iomanip> 
using namespace std;

int main() {
    // Complete the code.
    int a;
    int long b;
    char ch;
    float c;
    double d;
    cin >> a >> b >> ch >> c >> d;
    
    cout<<a<<endl;
    cout<<b<<endl;
    cout<<ch<<endl;
    cout<<fixed<<setprecision(3)<<c<<endl;
    cout<<fixed<<setprecision(9)<<d<<endl;
    //printf("%d\n%ld\n%c\n%0.3f\n%0.9lf",a,b,ch,c,d);
    return 0;
}

// Conditional Statements

#include<bits/stdc++.h>

using namespace std;

string ltrim(const string &);
string rtrim(const string &);

int main()
{
    string n_temp;
    getline(cin,n_temp);
    
    int n=stoi(ltrim(rtrim(n_temp)));
    
    // Write your code here
    
    if(n==1)
    cout<<"one"<<endl;
    else if(n==2)
    cout<<"two"<<endl;
    else if(n==3)
    cout<<"three"<<endl;
    else if(n==4)
    cout<<"four"<<endl;
    else if(n==5)
    cout<<"five"<<endl;
    else if(n==6)
    cout<<"six"<<endl;
    else if(n==7)
    cout<<"seven"<<endl;
    else if(n==8)
    cout<<"eight"<<endl;
    else if(n==9)
    cout<<"nine"<<endl;
    else
    cout<<"Greater than 9";
    
    return 0;
}

string ltrim(const string & str)
{
    string s(str);
    s.erase(s.begin(),find_if(s.begin(),s.end(),not1(ptr_fun<int,int>(isspace))));
    return s;
}

string rtrim(const string & str)
{
    string s(str);
    s.erase(find_if(s.rbegin(),s.rend(),not1(ptr_fun<int,int>(isspace))).base(),s.end());
    return s;
}

// For Loop

#include<iostream>
using namespace std;
int main()
{
    //Complete the code
    int a,b,i;
    string num[]={"","one","two","three","four","five","six","seven","eight","nine"};
    cin >> a >> b;
    for(i=a;i<=b;i++)
    {
        if(a>=1 && a<=9)
        {
            for(;a<=b;a++)
            {
                if(a<=9)
                cout<<num[a]<<endl;
                
                if(a>9)
                {
                    if(a%2==0)
                    cout<<"even"<<endl;
                    if(a%2==1)
                    cout<<"odd"<<endl;
                }
            }
        }
    }
    return 0;
}

// Functions

#include <iostream>
#include <cstdio>
using namespace std;

int max_of_four(int a, int b, int c, int d)
{
    if(a>b && a>c && a>d)
    return a;
    else if (b>a && b>c && b>d)
    return b;
    else if (c>a && c>b && c>d)
    return c;
    else 
    return d;
    
}

int main() {
    int a, b, c, d;
    //scanf("%d %d %d %d", &a, &b, &c, &d);
    cin>> a >> b >> c >> d;
    int ans = max_of_four(a, b, c, d);
    //printf("%d", ans);
    cout<< ans;
    
    return 0;
}

// Pointer

#include <stdio.h>
#include<iostream>
using namespace std;

void update(int *a,int *b) {
    // Complete this function    
    int sum,sub;
    sum = *a + *b;
    
    if(*a>*b)
    sub= *a - *b;
    else
    sub=*b-*a;
    
    *a=sum;
    *b=sub;
}

int main(){
    int a, b;
    int *pa = &a, *pb = &b;
   
    cin >> a >> b;
    update(pa, pb);
   
    cout << a << endl;
    cout << b << endl;

    return 0;
}

// Arrays Introduction

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int n,i;
    cin >> n;
    int arr[n];
    for(i=0;i<n;i++)
    cin >> arr[i];
    for(i=n;i>0;i--)
    cout << arr[i-1] <<" ";
    return 0;
}

// Variable Sized Arrays

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int n,q,i,j,k;
    cin >> n >> q;
    vector<vector<int>>a(n);
    for(i=0;i<n;i++)
    {
        cin >> k;
        a[i].resize(k);
        for(j=0;j<k;j++)
        cin >> a[i][j];
    }
    for(n=0;n<q;n++)
    {
        int i,j;
        cin >> i >> j;
        cout<< a[i][j] <<endl;
    }
    return 0;
}

// Attribute Parser

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <map>
#include <sstream>
#include <string>
using namespace std;

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    
int n, q,i;
cin>>n>>q;
string temp;
vector<string> hrml;
vector<string> quer;
cin.ignore();

for(i=0;i<n;i++)
{
    getline(cin,temp);
    hrml.push_back(temp);
}
for(i=0;i<q;i++)
{
    getline(cin,temp);
    quer.push_back(temp);
}

map<string, string> m;
vector<string> tag;

for(i=0;i<n;i++)
{
    temp=hrml[i];
    temp.erase(remove(temp.begin(), temp.end(), '\"' ),temp.end());
    temp.erase(remove(temp.begin(), temp.end(), '>' ),temp.end());

    if(temp.substr(0,2)=="</")
    {
        tag.pop_back();
    }
    else
    {
        stringstream ss;
        ss.str("");
        ss<<temp;
        string t1,p1,v1;
        char ch;
        ss>>ch>>t1>>p1>>ch>>v1;
        string temp1="";
        if(tag.size()>0)
        {
            temp1=*tag.rbegin();
            temp1=temp1+"."+t1;
        }
        else
            temp1=t1;
        tag.push_back(temp1);
        m[*tag.rbegin()+"~"+p1]=v1;
        while(ss)
        {
            ss>>p1>>ch>>v1;
            m[*tag.rbegin()+"~"+p1]=v1;
        }
    }

}

for(i=0;i<q;i++){
    if (m.find(quer[i]) == m.end())
        cout << "Not Found!\n";
    else
        cout<<m[quer[i]]<<endl;
}
return 0;

}

// StringStream

#include <iostream>
#include <sstream>
#include <vector>
using namespace std;

vector<int> parseInt(string str)
{
    //Complete this function
    stringstream ss(str);
    char ch;
    vector<int>a;
    int temp;
    while(ss>>temp)
    {
        a.push_back(temp);
        ss>>ch;
    }
    return a;
}

int main()
{
    string str;
    cin >> str;
    vector<int> integers= parseInt(str);
    for(int i=0;i<integers.size();i++)
    cout<<integers[i]<<"\n";
    
    return 0;
}

// Strings

#include <iostream>
#include <string>
using namespace std;

int main() {
	// Complete the program
    string a,b;
    char c1,c2;
    cin>>a;
    cin>>b;
    cout<<a.length()<<" "<<b.length()<<endl;
    cout<<a+b<<endl;
    c1=a[0];
    c2=b[0];
    a[0]=c2;
    b[0]=c1;
    cout<<a<<" "<<b<<endl;
  
    return 0;
}

// Structs

#include <iostream>
#include <cmath>
#include <vector>
#include <algorithm>
#include <cstdio>

using namespace std;

struct Student{
  int age;
  string first_name;
  string last_name;
  int standard;
};

int main()
{
    Student st;
    cin>> st.age >> st.first_name >> st.last_name >> st.standard;
    cout<<st.age <<" "<< st.first_name <<" "<< st.last_name<<" "<<st.standard;

    return 0;
}

// Class

#include <iostream>
#include <sstream>

using namespace std;
class Student{
  int age,standard;
  string first_name,last_name;
  public:
    void set_age(int a)
    {
        age=a;
    }
    int get_age()
    {
        return age;
    }
    void set_first_name(string name)
    {
        first_name=name;
    }
    string get_first_name()
    {
        return first_name;
    }
    void set_last_name(string lname)
    {
        last_name=lname;
    }
    string get_last_name()
    {
        return last_name;
    }
    void set_standard(int std)
    {
        standard=std;
    }
    int get_standard()
    {
        return standard;
    }
    string to_string()
    {
        stringstream ss;
        char ch=',';
        ss<<age<<ch<<first_name<<ch<<last_name<<ch<<standard;
        return ss.str();
    }
};

int main()
{
    int age,standard;
    string first_name,last_name;
    cin >> age >> first_name >> last_name >> standard;
    
    Student st;
    st.set_age(age);
    st.set_standard(standard);
    st.set_first_name(first_name);
    st.set_last_name(last_name);
    
    cout<<st.get_age()<<endl;
    cout<<st.get_first_name()<<", "<<st.get_last_name()<<endl;
    cout<<st.get_standard()<<endl;
    cout<<endl;
    cout<<st.to_string();
    return 0;
}

// Classes and Objects

#include <iostream>
#include <cmath>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cassert>

using namespace std;
//Write your Student class here
class Student{
  int score[5];
  public:
  int sum=0;
  void input()
  {
      for(int i=0; i<5; i++)
      {
          cin >> score[i];
          sum+=score[i];
      }
  }
  int calculateTotalScore()
  {
      return sum;
  }
  
};

int main()
{
    int n; // number of students
    cin >> n;
    Student *s = new Student[n]; //an arrays of n studnets
    
    for(int i=0;i<n;i++)
    {
        s[i].input();
    }
    
    //calculate kristen's score
    int kristen_score = s[0].calculateTotalScore();
    
    //determine how many studnets scored higher than kristen
    int count=0;
    for(int i=1; i<n ;i++)
    {
        int total = s[i].calculateTotalScore();
        if(total > kristen_score)
        {
            count++;
        }
    }
    //print result
    cout << count;
    
    return 0;
}

// Box It!

#include<bits/stdc++.h>

using namespace std;
//Implement the class Box  
//l,b,h are integers representing the dimensions of the box

// The class should have the following functions : 

// Constructors: 
// Box();
// Box(int,int,int);
// Box(Box);


// int getLength(); // Return box's length
// int getBreadth (); // Return box's breadth
// int getHeight ();  //Return box's height
// long long CalculateVolume(); // Return the volume of the box

//Overload operator < as specified
//bool operator<(Box& b)

//Overload operator << as specified
//ostream& operator<<(ostream& out, Box& B)

class Box{
  int l,b,h;
  public:
  Box(){
      l=b=h=0;
  }
  Box(int len,int breadth,int height)
  {
      l=len;
      b=breadth;
      h=height;
  }
  Box(const Box &B)
  {
      l=B.l;
      b=B.b;
      h=B.h;
  }
  int getLength()
  {
      return l;
  }
  int getBreadth()
  {
      return b;
  }
  int getHeight()
  {
      return h;
  }
  long long CalculateVolume()
  {
      return (long long) l*b*h;
  }
 friend bool operator < (Box &A, Box &B)
  {
      if((A.l<B.l) || ((A.b<B.b) && (A.l== B.l)) || ((A.h<B.h)&&(A.b==B.b)&&(A.l==B.l)))
      return true;
      else
      return false;
  }
  friend ostream &operator << (ostream &os,Box &obj)
  {
      os<<obj.l <<" "<<obj.b<<" "<<obj.h;
      return os;    
  }
};

void check2()
{
    int n;
    cin>>n;
    Box temp;
    for(int i=0;i<n;i++)
    {
        int type;
        cin>>type;
        if(type==1)
        {
            cout<<temp<<endl;
        }
        if(type==2)
        {
            int l,b,h;
            cin>>l>>b>>h;
            Box NewBox(l,b,h);
            temp=NewBox;
            cout<<temp<<endl;
        }
        if(type==3)
        {
            int l,b,h;
            cin>>l>>b>>h;
            Box NewBox(l,b,h);
            if(NewBox<temp)
            {
                cout<<"Lesser\n";
            }
            else
            {
                cout<<"Greater\n";
            }
        }
        if(type==4)
        {
            cout<<temp.CalculateVolume()<<endl;
        }
        if(type==5)
        {
            Box NewBox(temp);
            cout<<NewBox<<endl;
        }
    }
}
int main()
{
    check2();
}

// Inherited Code

#include <iostream>
#include <string>
#include <sstream>
#include <exception>
using namespace std;

/* Define the exception here */
class BadLengthException{
    int n;
    public:
    BadLengthException(int en)
    {
        n=en;
    }
    int what()
    {
        return n;
    }
};

bool checkUsername(string username)
{
    bool isvaild=true;
    int n = username.length();
    if(n<5)
    {
        throw BadLengthException(n);
    }
    for(int i=0;i<n-1;i++)
    {
        if(username[i] =='w' && username[i+1] == 'w')
        {
            isvaild=false;
        }
    }
    return isvaild;
}

int main()
{
    int T;
    cin >> T;
    while(T--)
    {
        string username;
        cin >>username;
        try{
            bool isvaild = checkUsername(username);
            if(isvaild)
            {
                cout<< "Valid" <<'\n';
            }
            else
            {
                cout<<"Invalid" <<'\n';
            }
        }
        catch(BadLengthException e)
        {
            cout<< "Too short: "<<e.what() <<'\n';
        }
    }
    return 0;
}

// Exceptional Server

#include <iostream>
#include <string>
#include <stdexcept>
#include <exception>
#include <vector>
#include <cmath>
using namespace std;

class Server{
  private:
  static int load;
  public:
  static int compute(long long A, long long B)
  {
      load+=1;
      if(A<0)
      {
          throw std::invalid_argument("A is negative");
      }
      vector<int> v(A,0);
      int real = -1, cmplx = sqrt(-1);
      if(B==0)
      throw 0;
      real = (A/B)*real;
      int ans= v.at(B);
      return real +A -B*ans;
      
  }
    static int getload()
    {
        return load;
    }
};
int Server::load=0;
int main()
{
    int T;
    cin>>T;
    while(T--)
    {
        long long A,B;
        cin>>A>>B;
        /*Enter your code here*/
        try{
          cout<<Server::compute(A,B)<<endl;  
        }
        catch(bad_alloc & error)
        {
            cout<<"Not enough memory"<<endl;
        }
        catch(exception & error)
        {
            cout<<"Exception: "<<error.what()<<endl;
        }
        catch(...)
        {
            cout<<"Other Exception"<<endl;
        }
        
    }
    cout<<Server::getload()<<endl;
    
    return 0;
}

// Virtual Functions

#include <iostream>
#include <cmath>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

class Person{
  
  public:
  string name;
  int age;
  
  virtual void getdata()
  {
      cin>>name>>age;
  }
  virtual void putdata()
  {
      cout<<name<<" "<<age<<endl;
  }
};
class Professor:public Person{
  public:
  Professor(){
      cur_id=++id;
  }
  int publication;
  static int id;
  int cur_id;
  void getdata()
  {
    cin>>name>>age>>publication;
  }
  void putdata()
  {
      cout<<name<<" "<<age<<" "<<publication<<" "<<cur_id<<endl;
  }
};
int Professor::id=0;
class Student:public Person{
  #define num_of_marks 6
  public:
  Student()
  {
      cur_id=++id;
  }
  static int id;
  int cur_id;
  int marks[num_of_marks];
  void getdata()
  {
      cin>>name>>age;
      for(int i=0;i<num_of_marks;i++)
      {
          cin>>marks[i];
      }
  }
  void putdata()
  {
      int marksSum=0;
      for(int i=0;i<num_of_marks;i++)
      {
          marksSum+=marks[i];
      }
      cout<<name<<" "<<age<<" "<<marksSum<<" "<<cur_id<<endl;
  }
};
int Student::id=0;
int main()
{
    int n,val;
    cin>>n; //The number of objects that is going to be created.
    Person *per[n];
    for(int i=0;i<n;i++)
    {
        cin>>val;
        if(val==1)
        {
            //if val is 1 current object is of type Professor
            per[i]=new Professor;
        }
        else per[i] = new Student;// Else the current object is of type Student
        per[i]->getdata();//Get the data from the user.
        
    }
    for(int i=0;i<n;i++)
    per[i]->putdata(); // Print the required output for each object.
    
    return 0;
}

// Abstract Classes - Polymorphism

#include <iostream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <set>
#include <cassert>
using namespace std;

struct Node{
   Node* next;
   Node* prev;
   int value;
   int key;
   Node(Node* p, Node* n, int k, int val):prev(p),next(n),key(k),value(val){};
   Node(int k, int val):prev(NULL),next(NULL),key(k),value(val){};
};

class Cache{
   
   protected: 
   map<int,Node*> mp; //map the key to the node in the linked list
   int cp;  //capacity
   Node* tail; // double linked list tail pointer
   Node* head; // double linked list head pointer
   virtual void set(int, int) = 0; //set function
   virtual int get(int) = 0; //get function

};
class LRUCache:public Cache{
    int capacity;
    public:
    LRUCache(int cap)
    {
        cp=cap;
        capacity=cap;
        tail=NULL;
        head=NULL;
    }
    void set(int key,int value) override{
        if(mp.find(key) != mp.end())
        {
            Node* node=mp[key];
            node->value=value;
            if(node->prev!=NULL)
            {
                node->prev->next=node->next;
                if (node->next!=NULL)
                node->next->prev=node->prev;
                else 
                tail=node->prev;
                node->prev=NULL;
                node->next=NULL;
                head->prev=node;
                head=node;
            }
        }
        else
        {
            Node *node=new Node(NULL,head,key,value);
            if(head!=NULL)
            head->prev=node;
            head=node;
            if(tail==NULL)
            tail=node;
            if(mp.size()==capacity)
            {
                mp.erase(tail->key);
                tail=tail->prev;
                delete tail->next;
                tail->next=NULL;
                
            }
            mp[key]=node;
        }
    }
    
    int get(int key) override{
        if(mp.find(key)!=mp.end()){
            Node *node=mp[key];
            if (node->prev!=NULL) {
                node->prev->next=node->next;
                if(node->next!=NULL)
                node->next->prev=node->prev;
                else
                 tail=node->prev;
                 node->prev=NULL;
                 node->next=head;
                 head->prev=node;
                 head=node;
            }
            return node->value;
        }
        return -1;
    }
};

int main() {
   int n, capacity,i;
   cin >> n >> capacity;
   LRUCache l(capacity);
   for(i=0;i<n;i++) {
      string command;
      cin >> command;
      if(command == "get") {
         int key;
         cin >> key;
         cout << l.get(key) << endl;
      } 
      else if(command == "set") {
         int key, value;
         cin >> key >> value;
         l.set(key,value);
      }
   }
   return 0;
}

// Vector - Sort

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

int main()
{
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int n,i,x;
    cin>>n;
    vector<int>arr;
    for(i=0;i<n;i++)
    {
        cin>>x;
        arr.push_back(x);
    }
    sort(arr.begin(),arr.end());
    for(i=0;i<arr.size();i++)
    cout<<arr[i]<<' ';
    return 0;
}

// Vector-Erase

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

int main()
{
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int n,i,x;
    vector<int> v;
    cin>>n;
    for(i=0;i<n;i++)
    {
        cin>>x;
        v.push_back(x);
    }
    int a,b;
    cin>>x>>a>>b;
    v.erase(v.begin()+x-1);
    v.erase(v.begin()+a-1, v.begin()+b-1);
    cout<<v.size()<<'\n';
    
    for(i=0;i<v.size();i++)
    {
        cout<<v[i]<<' ';
    }
    return 0;
}
// Lower Bound-STL

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

int main()
{
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int n,q,i,x;
    cin>>n;
    vector <int> v;
    for(i=0;i<n;i++)
    {
        cin>>x;
        v.push_back(x);
    }
    cin>>q;
    for(i=0;i<q;i++)
    {
        cin>>x;
        auto low = lower_bound(v.begin(),v.end(),x);
        if(v[low-v.begin()]==x)
        cout<<"Yes "<<low-v.begin()+1<<endl;
        else
        cout<<"No "<<low-v.begin()+1<<endl;
    }
    
    
    return 0;
}

// Sets-STL

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <set>
#include <algorithm>
using namespace std;

int main()
{
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int n,i;
    cin>>n;
    set<int>s;
    for(i=0;i<n;i++)
    {
        int x,y;
        cin>>y>>x;
        switch(y)
        {
            case 1:
            {
                s.insert(x);
                break;
            }
            case 2:
            {
                s.erase(x);
                break;
            }
            case 3:
            {
                set<int>::iterator itr=s.find(x);
                if(itr==s.end())
                cout<<"No"<<endl;
                else
                cout<<"Yes"<<endl;
                break;
            }
        }
        
    }
    
    
    return 0;
}

// Maps-STL

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <set>
#include <map>
#include <algorithm>
using namespace std;

int main()
{
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int q;
    cin>>q;
    map<string,int>mp;
    for(int i=0;i<q;i++)
    {
        int type;
        cin>>type;
        if(type==1)
        {
            string name;
            int marks;
            cin>>name>>marks;
            mp[name]+=marks;
        }
        else if (type==2)
        {
            string name;
            cin>>name;
            mp.erase(name);
        }
        else if(type==3)
        {
            string name;
            cin>>name;
            cout<<mp[name]<<endl;
        }
    }

    return 0;
}

// Print Pretty

#include <iostream>
#include <iomanip>
using namespace std;

int main()
{
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int T;
    cin>>T;
    cout<<setiosflags(ios::uppercase);
    cout<< setw(0xf)<<internal;
    while(T--)
    {
        double A;cin>>A;
        double B;cin>>B;
        double C;cin>>C;
        /*Enter your code here*/
        
        cout<<hex<<left<<showbase<<nouppercase;
        cout<<(long long)A<<endl;
        cout<<dec<<right<<setw(15)<<setfill('_')<<showpos<<fixed<<setprecision(2);
        cout<<B<<endl;
        cout<<scientific<<uppercase<<noshowpos<<setprecision(9);
        cout<<C<<endl;
    }
    return 0;
}

// Deque-STL

#include <iostream>
#include <deque> 
using namespace std;

void printKMax(int arr[], int n, int k){
	//Write your code here.
    deque<int>dq;
    int i;
    for(i=0;i<k;i++)
    {
        while(!dq.empty() && arr[i]>=arr[dq.back()])
        {
            dq.pop_back();
        }
        dq.push_back(i);
    }
    for(;i<n;i++)
    {
        cout<<arr[dq.front()]<<" ";
        while (!dq.empty() && dq.front()<=i-k) {
            dq.pop_front();
        }
        while (!dq.empty() && arr[i]>=arr[dq.back()]) {
            dq.pop_back();
        }
        dq.push_back(i);
    }
    cout<<arr[dq.front()]<<endl;
}

int main(){
  
	int t;
	cin >> t;
	while(t>0) {
		int n,k;
    	cin >> n >> k;
    	int i;
    	int arr[n];
    	for(i=0;i<n;i++)
      		cin >> arr[i];
    	printKMax(arr, n, k);
    	t--;
  	}
  	return 0;
}

// Inheritance Introduction

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

class Triangle{
  public:
  void triangle()
  {
      cout<<"I am a triangle\n";
  }
};
class Isosceles: public Triangle
{
    public:
    void isosceles(){
        cout<<"I am an isosceles triangle\n";
    }
    //Write your code here
    void description()
    {
        cout<<"In an isosceles triangle two sides are equal\n";
    }
};

int main()
{
    Isosceles isc;
    isc.isosceles();
    isc.description();
    isc.triangle();
    
    return 0;
}

// Hotel Prices

#include <iostream>
#include <vector>

using namespace std;

class HotelRoom {
public:
    HotelRoom(int bedrooms, int bathrooms) 
    : bedrooms_(bedrooms), bathrooms_(bathrooms) {}
    
    int get_price() {
        return 50*bedrooms_ + 100*bathrooms_;
    }
private:
    int bedrooms_;
    int bathrooms_;
};

class HotelApartment : public HotelRoom {
public:
    HotelApartment(int bedrooms, int bathrooms) 
    : HotelRoom(bedrooms+2, bathrooms) {}

    int get_price() {
        return HotelRoom::get_price() + 100;
    }
};

int main() {
    int n;
    cin >> n;
    vector<HotelRoom*> rooms;
    for (int i = 0; i < n; ++i) {
        string room_type;
        int bedrooms;
        int bathrooms;
        cin >> room_type >> bedrooms >> bathrooms;
        if (room_type == "standard") {
            rooms.push_back(new HotelRoom(bedrooms, bathrooms));
        } else {
            rooms.push_back(new HotelApartment(bedrooms, bathrooms));
        }
    }

    int total_profit = 0;
    for (auto room : rooms) {
        total_profit += room->get_price();
    }
    cout << total_profit << endl;

    for (auto room : rooms) {
        delete room;
    }
    rooms.clear();

    return 0;
}

// Cpp exception handling

#include <iostream>
#include <stdexcept>
using namespace std;

int largest_proper_divisor(int n)
{
    if(n==0)
    {
        throw invalid_argument("largest proper divisor is not defined for n==0");
    }
    if(n==1)
    {
        throw invalid_argument("largest proper divisor is not defined for n==1");
    }
    for(int i=n/2;i>=1;i++)
    {
        if(n%i==0)
        {
            return i;
        }
    }
    return -1;// will never happen
}
void process_input(int n)
{
    try{
        int d=largest_proper_divisor(n);
        cout<<"result="<<d<<endl;
    }
    catch(const invalid_argument &e)
    {
        cout<<e.what()<<endl;
    }
    cout<<"returning control flow to caller"<<endl;
}
int main()
{
    int n;
    cin>>n;
    process_input(n);
    return 0;
}

// Rectangle Area

#include <iostream>
using namespace std;
/*Create classes Rectangle and RectangleArea*/
class Rectangle{
  protected:
  int width,height;
  public:
  void read_input()
  {
      cin>>width>>height;
  }
  void display()
  {
      cout<<width<<" "<<height<<endl;
  }
};
class RectangleArea:public Rectangle{
  public:
  void display()
  {
      cout<<width*height<<endl;
  }
};
int main()
{
    /*Declare a RectangleArea object*/
    RectangleArea r_area;
    /*Read the width and height*/
    r_area.read_input();
    /*print the width and height*/
    r_area.Rectangle::display();
    /*print the area*/
    r_area.display();
    
    return 0;
}
// Multi Level Inheritance

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

class Triangle{
	public:
		void triangle(){
			cout<<"I am a triangle\n";
		}
};

class Isosceles : public Triangle{
  	public:
  		void isosceles(){
    		cout<<"I am an isosceles triangle\n";
  		}
};

//Write your code here.
class Equilateral:public Isosceles{
    public:
          void equilateral(){
            cout<<"I am an equilateral triangle\n";
          }
    
};
int main(){
  
    Equilateral eqr;
    eqr.equilateral();
    eqr.isosceles();
    eqr.triangle();
    return 0;
}

// Overloading Ostream Operator

#include <iostream>

using namespace std;
class Person{
    public:
    Person(const string &first_name, const string &last_name) : first_name_(first_name),last_name_(last_name){}
    
    const string &get_first_name() const{
        return first_name_;
    }
    const string &get_last_name() const{
        return last_name_;
    }
    private:
    string first_name_;
    string last_name_;
};
//Enter your code here
ostream &operator << (ostream &out, const Person &obj)
{
    char ch=',';
    out<<"first_name="<<obj.get_first_name()<<ch<<"last_name="<<obj.get_last_name();
    return out;
}


int main()
{
    string first_name,last_name,event;
    cin>>first_name>>last_name>>event;
    auto p = Person(first_name,last_name);
    cout<<p<< " "<<event<<endl;
    return 0;
}

// Messages Order

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

class Message {
    string text;
    static int id;
    int cur_id;
public: 
    Message() {
        cur_id=++id;
    }
    Message(string t)
    {
        cur_id=++id;
        text=t;
    }
    const string& get_text() {
        return text;
    }
    bool operator < (const Message & x)
    {
        if(cur_id < x.cur_id)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
};
int Message::id=0;

class MessageFactory {
public:
    MessageFactory() {}
    Message create_message(const string& text) {
     Message m= Message(text);
     return m;   
    }
};

class Recipient {
public:
    Recipient() {}
    void receive(const Message& msg) {
        messages_.push_back(msg);
    }
    void print_messages() {
        fix_order();
        for (auto& msg : messages_) {
            cout << msg.get_text() << endl;
        }
        messages_.clear();
    }
private:
    void fix_order() {
        sort(messages_.begin(), messages_.end());
    }
    vector<Message> messages_;
};

class Network {
public:
    static void send_messages(vector<Message> messages, Recipient& recipient) {
    // simulates the unpredictable network, where sent messages might arrive in unspecified order
        random_shuffle(messages.begin(), messages.end());         
        for (auto msg : messages) {
            recipient.receive(msg);
        }
    }
};

int main() {
    MessageFactory message_factory;
    Recipient recipient;
    vector<Message> messages;
    string text;
    while (getline(cin, text)) {
        messages.push_back(message_factory.create_message(text));
    }
    Network::send_messages(messages, recipient);
    recipient.print_messages();
}

// Accessing Inherited Functions

#include<iostream>

using namespace std;

class A
{
    public:
        A(){
            callA = 0;
        }
    private:
        int callA;
        void inc(){
            callA++;
        }

    protected:
        void func(int & a)
        {
            a = a * 2;
            inc();
        }
    public:
        int getA(){
            return callA;
        }
};

class B
{
    public:
        B(){
            callB = 0;
        }
    private:
        int callB;
        void inc(){
            callB++;
        }
    protected:
        void func(int & a)
        {
            a = a * 3;
            inc();
        }
    public:
        int getB(){
            return callB;
        }
};

class C
{
    public:
        C(){
            callC = 0;
        }
    private:
        int callC;
        void inc(){
            callC++;
        }
    protected:
        void func(int & a)
        {
            a = a * 5;
            inc();
        }
    public:
        int getC(){
            return callC;
        }
};

class D :public A,public B,public C
{

	int val;
	public:
		//Initially val is 1
		 D()
		 {
		 	val = 1;
		 }


		 //Implement this function
		 void update_val(int new_val)
		 {
             int a=new_val;
             while(new_val!=0)
             {
                 if(val==a)
                 break;
                 if(new_val%2==0)
                 {
                     A::func(val);
                     new_val/=2;
                 }
                 else if(new_val%3==0)
                 {
                     B::func(val);
                     new_val/=3;
                 }
                 else if(new_val%5==0)
                 {
                     C::func(val);
                     new_val/=5;
                 }
             }
		 }
		 //For Checking Purpose
		 void check(int); //Do not delete this line.
};



void D::check(int new_val)
{
    update_val(new_val);
    cout << "Value = " << val << endl << "A's func called " << getA() << " times " << endl << "B's func called " << getB() << " times" << endl << "C's func called " << getC() << " times" << endl;
}


int main()
{
    D d;
    int new_val;
    cin >> new_val;
    d.check(new_val);

}

// Magic Spells

#include <iostream>
#include <vector>
#include <string>
using namespace std;

class Spell { 
    private:
        string scrollName;
    public:
        Spell(): scrollName("") { }
        Spell(string name): scrollName(name) { }
        virtual ~Spell() { }
        string revealScrollName() {
            return scrollName;
        }
};

class Fireball : public Spell { 
    private: int power;
    public:
        Fireball(int power): power(power) { }
        void revealFirepower(){
            cout << "Fireball: " << power << endl;
        }
};

class Frostbite : public Spell {
    private: int power;
    public:
        Frostbite(int power): power(power) { }
        void revealFrostpower(){
            cout << "Frostbite: " << power << endl;
        }
};

class Thunderstorm : public Spell { 
    private: int power;
    public:
        Thunderstorm(int power): power(power) { }
        void revealThunderpower(){
            cout << "Thunderstorm: " << power << endl;
        }
};

class Waterbolt : public Spell { 
    private: int power;
    public:
        Waterbolt(int power): power(power) { }
        void revealWaterpower(){
            cout << "Waterbolt: " << power << endl;
        }
};

class SpellJournal {
    public:
        static string journal;
        static string read() {
            return journal;
        }
}; 
string SpellJournal::journal = "";

void counterspell(Spell *spell) {

  /* Enter your code here */
        if (Fireball* fireball = dynamic_cast<Fireball*>(spell)) {
        fireball->revealFirepower();
    }
    else if (Frostbite* frostbite = dynamic_cast<Frostbite*>(spell)) {
        frostbite->revealFrostpower();
    }
    else if (Thunderstorm* thunderstorm = dynamic_cast<Thunderstorm*>(spell)) {
        thunderstorm->revealThunderpower();
    }
    else if (Waterbolt* waterbolt = dynamic_cast<Waterbolt*>(spell)) {
        waterbolt->revealWaterpower();
    }
    else {
        string scrollName = spell->revealScrollName();
        string journal = SpellJournal::read();
        int n = scrollName.length();
        int m = journal.length();

        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (scrollName[i - 1] == journal[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else {
                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }

        cout << dp[n][m] << endl;
    }
}

class Wizard {
    public:
        Spell *cast() {
            Spell *spell;
            string s; cin >> s;
            int power; cin >> power;
            if(s == "fire") {
                spell = new Fireball(power);
            }
            else if(s == "frost") {
                spell = new Frostbite(power);
            }
            else if(s == "water") {
                spell = new Waterbolt(power);
            }
            else if(s == "thunder") {
                spell = new Thunderstorm(power);
            } 
            else {
                spell = new Spell(s);
                cin >> SpellJournal::journal;
            }
            return spell;
        }
};

int main() {
    int T;
    cin >> T;
    Wizard Arawn;
    while(T--) {
        Spell *spell = Arawn.cast();
        counterspell(spell);
    }
    return 0;
}

// C++ Class Templates

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <cassert>
using namespace std;

/*Write the class AddElements here*/
template <class T>
class AddElements{ 
    T element;
    public:
    AddElements(const T& element):element(element){}
    T add(const T& other)
    {
        return element+other;
    }
    T concatenate(const T& other)
    {
        return element+other;
    }
};

int main () {
  int n,i;
  cin >> n;
  for(i=0;i<n;i++) {
    string type;
    cin >> type;
    if(type=="float") {
        double element1,element2;
        cin >> element1 >> element2;
        AddElements<double> myfloat (element1);
        cout << myfloat.add(element2) << endl;
    }
    else if(type == "int") {
        int element1, element2;
        cin >> element1 >> element2;
        AddElements<int> myint (element1);
        cout << myint.add(element2) << endl;
    }
    else if(type == "string") {
        string element1, element2;
        cin >> element1 >> element2;
        AddElements<string> mystring (element1);
        cout << mystring.concatenate(element2) << endl;
    }
  }
  return 0;
}

// Preprocessor Solution

#include <iostream>
#include <vector>
using namespace std;
#define toStr(x) #x
#define io(x) cin >> x
#define INF 10000000
#define foreach(v, i) for(int i=0; i<v.size(); i++)
#define FUNCTION(name, op) void name(int &a,int b){ if(b op a) a=b;}

#if !defined toStr || !defined io || !defined FUNCTION || !defined INF
#error Missing preprocessor definitions
#endif

FUNCTION(minimum, <)
FUNCTION(maximum, >)
int main()
{
    int n;
    cin >> n;
    vector<int> v(n);
    foreach(v, i){
        io(v)[i];
    }
    int mn = INF;
    int mx = -INF;
    foreach(v, i){
        minimum(mn, v[i]);
        maximum(mx, v[i]);
    }
    int ans = mx - mn;
    cout << toStr(Result =) <<' '<< ans;
    return 0;
}

// Operator Overloading

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
class Matrix{
  public:
  vector<vector<int >>a;
  Matrix & operator +(const Matrix &x)
  {
      for(int m=0;m<x.a.size();m++)
      {
          for(int n=0;n<x.a[0].size();n++)
          {
              a[m][n]=a[m][n]+x.a[m][n];
          }
      }
      return *this;
  }  
};
int main () {
   int cases,k;
   cin >> cases;
   for(k=0;k<cases;k++) {
      Matrix x;
      Matrix y;
      Matrix result;
      int n,m,i,j;
      cin >> n >> m;
      for(i=0;i<n;i++) {
         vector<int> b;
         int num;
         for(j=0;j<m;j++) {
            cin >> num;
            b.push_back(num);
         }
         x.a.push_back(b);
      }
      for(i=0;i<n;i++) {
         vector<int> b;
         int num;
         for(j=0;j<m;j++) {
            cin >> num;
            b.push_back(num);
         }
         y.a.push_back(b);
      }
      result = x+y;
      for(i=0;i<n;i++) {
         for(j=0;j<m;j++) {
            cout << result.a[i][j] << " ";
         }
         cout << endl;
      }
   }  
   return 0;
}

// Overload Operators

#include<iostream>

using namespace std;

class Complex
{
public:
    int a,b;
    void input(string s)
    {
        int v1=0;
        int i=0;
        while(s[i]!='+')
        {
            v1=v1*10+s[i]-'0';
            i++;
        }
        while(s[i]==' ' || s[i]=='+'||s[i]=='i')
        {
            i++;
        }
        int v2=0;
        while(i<s.length())
        {
            v2=v2*10+s[i]-'0';
            i++;
        }
        a=v1;
        b=v2;
    }
};

//Overload operators + and << for the class complex
//+ should add two complex numbers as (a+ib) + (c+id) = (a+c) + i(b+d)
//<< should print a complex number in the format "a+ib"
Complex operator + (const Complex &x,const Complex &y){
 Complex ret;
 ret.a=x.a+y.a;
 ret.b=x.b+y.b;   
 return ret;
}
ostream &operator << (ostream &out,const Complex &x){
    if(x.b<0)
    {
        out<<x.a<<"-i"<<x.b<<endl;
    }
    else if(x.b>0)
    {
       out<<x.a<<"+i"<<x.b<<endl;
    }
    else {
    out<<x.a;
    }
    return out;
}


int main()
{
    Complex x,y;
    string s1,s2;
    cin>>s1;
    cin>>s2;
    x.input(s1);
    y.input(s2);
    Complex z=x+y;
    cout<<z<<endl;
}

// Attending Workshops

#include<bits/stdc++.h>

using namespace std;

//Define the structs Workshops and Available_Workshops.
//Implement the functions initialize and CalculateMaxWorkshops
struct Workshops{
  friend ostream &operator <<(ostream &os,const Workshops &obj);
  int start_time;
  int end_time;
  int duration;
  bool operator<(const Workshops &rhs)
  {
    return (this->end_time < rhs.end_time);
  }
};
ostream &operator <<(ostream &os,const Workshops &obj)
{
    os<<obj.start_time<<": "<<obj.end_time<<": "<<obj.duration<<endl;
    return os;
}
struct Available_Workshops{
    int n;
    vector<Workshops> vec;
};
Available_Workshops * initialize(int start_time[],int duration[],int num)
{
    Available_Workshops *avail= new Available_Workshops;
    avail->n=num;
    Workshops test;
    for(int i=0;i<num;i++)
    {
        test.start_time=start_time[i];
        test.duration=duration[i];
        test.end_time=start_time[i]+duration[i];
        avail->vec.push_back(test);
    }
    sort(avail->vec.begin(),avail->vec.end());
    return avail;
}
int CalculateMaxWorkshops(Available_Workshops *test)
{
    int count=0;
    int end=0;
    for(int i=0;i<test->n;i++)
    {
        if(test->vec.at(i).start_time>=end)
        {
            end=test->vec.at(i).end_time;
            count++;
        }
    }
    return count;

   /* int w_count=1;
    int test_end_time=test->vec.at(0).end_time;
    for(int i=1;i<test->n;i++)
    {
        if(test_end_time<=test->vec.at(i).start_time)
        {
            w_count++;
            test_end_time=test->vec.at(i).end_time;
        }
    }
    return w_count;*/
}

int main(int argc, char *argv[]) {
    int n; // number of workshops
    cin >> n;
    // create arrays of unknown size n
    int* start_time = new int[n];
    int* duration = new int[n];

    for(int i=0; i < n; i++){
        cin >> start_time[i];
    }
    for(int i = 0; i < n; i++){
        cin >> duration[i];
    }

    Available_Workshops * ptr;
    ptr = initialize(start_time,duration, n);
    cout << CalculateMaxWorkshops(ptr) << endl;
    return 0;
}

// C++ Class Template Specialization

#include <iostream>
using namespace std;
enum class Fruit { apple, orange, pear };
enum class Color { red, green, orange };

template <typename T> struct Traits;

// Define specializations for the Traits class template here.
template<>
struct Traits<Fruit>
{
    static string name(int index)
    {
        switch (static_cast<Fruit>(index)) {
            case Fruit:: apple:
            return "apple";
            case Fruit::orange:
            return "orange";
            case Fruit::pear:
            return "pear";
            default:
            return "unknown";
        }
    }
};
template<>
struct Traits<Color>
{
  static string name(int index)
  {
      switch (static_cast<Color>(index)) {
          case Color::red:
          return "red";
          case Color::green:
          return "green";
          case Color::orange:
          return "orange";
          default:
          return "unknown";
      }
  }  
};


int main()
{
	int t = 0; std::cin >> t;

    for (int i=0; i!=t; ++i) {
        int index1; std::cin >> index1;
        int index2; std::cin >> index2;
        cout << Traits<Color>::name(index1) << " ";
        cout << Traits<Fruit>::name(index2) << "\n";
    }
}

// C++ Variadics

#include <iostream>
using namespace std;

// Enter your code for reversed_binary_value<bool...>()
template <bool a> 
int reversed_binary_value()
{ 
   return a; 
}

template <bool a, bool b, bool... d>
int reversed_binary_value() {
  return (reversed_binary_value<b, d...>() << 1) + a;
}



template <int n, bool...digits>
struct CheckValues {
  	static void check(int x, int y)
  	{
    	CheckValues<n-1, 0, digits...>::check(x, y);
    	CheckValues<n-1, 1, digits...>::check(x, y);
  	}
};

template <bool...digits>
struct CheckValues<0, digits...> {
  	static void check(int x, int y)
  	{
    	int z = reversed_binary_value<digits...>();
    	std::cout << (z+64*y==x);
  	}
};

int main()
{
  	int t; std::cin >> t;

  	for (int i=0; i!=t; ++i) {
		int x, y;
    	cin >> x >> y;
    	CheckValues<6>::check(x, y);
    	cout << "\n";
  	}
}

// Bit Array

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    unsigned long long n,s,p,q,v;
    cin>>n>>s>>p>>q;
    unsigned long long i,a0=s,a=s,ap=0,k=0;
    
    v=pow(2,31);
    for(i=0;i<n;i++)
    {
        a=(a*p+q)%v;
        if((a==a0 || a==ap)&& i!=0)
        {
            k=i+1;
            break;
        }
        ap=a;
    }
    if(i==n)
    k=i;
    cout<< k << endl;
    return 0;
}

/***************************END***************************************************/